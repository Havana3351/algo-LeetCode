# 2022.4.1 第一题——两数之和

[toc]

## 题目

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。 

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

**提示：**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **只会存在一个有效答案**

**进阶：**你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？

## 暴力解法

```javascript
var twoSum = function(nums, target) {
    for(let i=0;i<nums.length;i++){
        for(let j=0;j<nums.length;j++){
            if(nums[i]+nums[j]==target && i!=j){
                return [i,j];
            }
        }
    }
};
```

### 复杂度分析

#### 时间复杂度

数组长度是n，算法大概执行了多少次？这里我们只算类似比较这种，对时间影响较大的，赋值操作等基本操作一般是不计算在内的。

暴力解法中，我们利用了双重 for 循环，每一个循环最坏要执行n次，所以时间复杂度为 **O（n^2）**

#### 空间复杂度

空间复杂度，**主要计算除了题目要求外的，我们自己实现过程中，所使用的空间大小**。

本题中我们只使用了i , j两个变量，其空间大小是不随着数据量变化而变化的。所以暴力解法的空间复杂度为 **O（1）**

## 优化过的解法

```javascript
var twoSum = function(nums, target) {
    let obj = {};
    for(let i=0;i<nums.length;i++){
        let num = nums[i];
        if(num in obj){
            return [i,obj[num]]
        }else{
            let n = target - num;
            obj[n] = i;
        }
    }
};
```

### 复杂度分析

#### 时间复杂度

数组长度是n，一重for循环，循环体内还有一个 if 比较，但是因为obj的查找算法时间复杂度为O（1）所以对算法整体的复杂度没有影响。

综上所述，本优化解法的时间复杂度为**O（n）**！

#### 空间复杂度

因为我们定义了额外的数组来存放每一个nums对应的，达到target需要的值。最坏的情况就是吧nums中的数据全部存起来。

所以空间复杂度为：**O（n）**

**这就是一个经典的用空间换时间的优化算法。**



## 另外一种优化算法，在时间复杂度和空间复杂度上做了一个权衡

这个解法是受第167题的启发，我们可以**先对数组进行排序**，然后再按照167题的**双指针法**进行求解。

### 时间复杂度

时间复杂度由两部分组成，第一部分为**数组排序产生的**，**O（nlogn）**。第二部分为双指针法产生的，**O（n）**。两部分合起来，总的时间复杂度为**O（nlogn）**。

### 空间复杂度

空间复杂度也是两部分，排序算法最好可以做到**O（1）**。双指针法也是常数级。所以最好的情况为**O（1）**。





