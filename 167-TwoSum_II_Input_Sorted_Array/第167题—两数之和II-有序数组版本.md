# 2022.4.19 第167题——两数之和II-有序数组版本

[toc]

## 题目

|  Category  |   Difficulty    | Likes | Dislikes |
| :--------: | :-------------: | :---: | :------: |
| algorithms | Medium (58.47%) |  767  |    -     |

给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。

以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。

你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。

你所设计的解决方案必须只使用**常量级**的额外空间。

 

**示例 1：**

```
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
```

**示例 2：**

```
输入：numbers = [2,3,4], target = 6
输出：[1,3]
解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。
```

**示例 3：**

```
输入：numbers = [-1,0], target = -1
输出：[1,2]
解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
```

 

**提示：**

- `2 <= numbers.length <= 3 * 10`<sup>4</sup>
- `-1000 <= numbers[i] <= 1000`
- `numbers` 按 **非递减顺序** 排列
- `-1000 <= target <= 1000`
- **仅存在一个有效答案**

------

[Discussion](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/comments/) | [Solution](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/)



## 题目关键信息解析

本题的题目中有一些小坑和小要求，需要注意！

1. 数组下标虽然说是从1开始，结合题目给出的实例，这里隐含的意思是你返回的数组下标，要符合正常人类的习惯，下标从1开始算，但是numbers的下标还是从0开始的。
2. **非递减顺序排列**，翻译一下就是按照**递增顺序排列**
3. 空间复杂度要是常量级，也就是说我们只能定义单个的变量使用，不能定义和数组元素数量有关系的量，就类似第一题中的，自定义的存储信息的数组。



## 解法

### 解题思路

1. 首先想到的肯定是暴力解法了，但是和第一题一样，暴力解法的时间复杂度是——**O（n<sup>2</sup>）**不够优秀，并且如果这样写那么这一题的数组有序，不就完全成为了一个废弃条件了嘛，所以要进行优化。

2. 现在写完，看完题解后知道了这个方法叫——**双指针法**。何为双指针法呢？

   > 其实我个人认为和二分法是有异曲同工之妙的。**二分法**是在有序数组（以递增为例）中，先从数组中间找起，如果大于目标值就从跳到左半边数组的中间，如果小于目标值就跳到右半边数组的中间……直到找到目标值。
   >
   > 
   >
   > **双指针法**就是其变体。二分法是在有序数组中找到一个值和目标值对应。而本题需要在数组中，找到两个值的和，去对应目标值。一个指针指向最小值，一个指针指向最大值。用其和来和目标值进行比较，大了就缩小尾指针，小了就扩大头指针，以两面夹逼法，最终找到目标值。 



### 解题复杂度分析

#### 时间复杂度

优化过的算法，其时间复杂度来源主要是到底要执行多少次 while 循环。我们对 while 循环进行观察，其条件为

left < right，所以我们可知最多也就n次，所以时间复杂度是——**O（n）**

#### 空间复杂度

因为我们额外申请了两个指针和一个保存其和的 sum，所以空间复杂度为常量级——**O（1）**



### 解题代码

```javascript
var twoSum = function(numbers, target) {

    // 有序列表 + 双指针 实现两数之和
    let left = 0; //头指针
    let right =  numbers.length - 1; //尾指针

    while(left < right){
        let sum = numbers[left] + numbers[right]; // 目前的和
        if(sum === target){ //如果相等则直接返回，记得+1来满足人类习惯
            return [left+1, right+1];
        }else if(sum > target){ // 如果大了就缩小尾指针
            right--;
        }else if(sum < target){ // 如果小了就扩大头指针
            left++;
        }
    }
};
```



## LeetCode大哥的解析，写的很好 [地址](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/yi-zhang-tu-gao-su-ni-on-de-shuang-zhi-zhen-jie-fa/)

解题思路：
很多人做这个题目想不到正确的 O(n)O(n) 解法，即使看了答案理解了，下次再做的时候还是会忘记。要想真正理解这道题，就要明白解法背后的道理。这样不仅可以记住这道题，还能举一反三解决类似的题目。

很多题解只给出了双指针解法的代码，但没有说明解法的正确性。为什么双指针往中间移动时，不会漏掉某些情况呢？要解答这个问题，我们要从缩减搜索空间的角度思考这个解法。下面我将以文字和图片两种方式进行讲解。

首先放上参考答案：

```C++
vector<int> twoSum(vector<int>& numbers, int target) {
    int i = 0;
    int j = numbers.size()-1;
    while (i < j) {
        int sum = numbers[i] + numbers[j];
        if (sum < target) {
            i++;
        } else if (sum > target) {
            j--;
        } else {
            return vector<int>{i+1, j+1};
        }
    }
    return vector<int>{-1, -1};
}
```

需要注意的是，虽然本题叫做 Two Sum II，但解法和 Two Sum 完全不同。

图解双指针解法的原理
在这道题中，我们要寻找的是符合条件的一对下标 (i, j)(i,j)，它们需要满足的约束条件是：

ii、jj 都是合法的下标，即 0 \le i < n, 0 \le j < n0≤i<n,0≤j<n
i < ji<j（题目要求）
而我们希望从中找到满足 A[i] + A[j] == target 的下标 (i, j)(i,j)。以 n = 8n=8 为例，这时候全部的搜索空间是：



由于 ii、jj 的约束条件的限制，搜索空间是白色的倒三角部分。可以看到，搜索空间的大小是 O(n^2)O(n 
2
 ) 数量级的。如果用暴力解法求解，一次只检查一个单元格，那么时间复杂度一定是 O(n^2)O(n 
2
 )。要想得到 O(n)O(n) 的解法，我们就需要能够一次排除多个单元格。那么我们来看看，本题的双指针解法是如何削减搜索空间的：

一开始，我们检查右上方单元格 (0, 7)(0,7)，即计算 A[0] + A[7] ，与 target 进行比较。如果不相等的话，则要么大于 target，要么小于 target。



假设此时 A[0] + A[7] 小于 target。这时候，我们应该去找和更大的两个数。由于 A[7] 已经是最大的数了，其他的数跟 A[0] 相加，和只会更小。也就是说 A[0] + A[6] 、A[0] + A[5]、……、A[0] + A[1] 也都小于 target，这些都是不合要求的解，可以一次排除。这相当于 i=0i=0 的情况全部被排除。对应用双指针解法的代码，就是 i++，对应于搜索空间，就是削减了一行的搜索空间，如下图所示。



排除掉了搜索空间中的一行之后，我们再看剩余的搜索空间，仍然是倒三角形状。我们检查右上方的单元格 (1, 7)(1,7)，计算 A[1] + A[7] 与 target 进行比较。



假设此时 A[0] + A[7] 大于 target。这时候，我们应该去找和更小的两个数。由于 A[1] 已经是当前搜索空间最小的数了，其他的数跟 A[7] 相加的话，和只会更大。也就是说 A[1] + A[7] 、A[2] + A[7]、……、A[6] + A[7] 也都大于 target，这些都是不合要求的解，可以一次排除。这相当于 j=0j=0 的情况全部被排除。对应用双指针解法的代码，就是 j++，对应于搜索空间，就是削减了一列的搜索空间，如下图所示。



可以看到，无论 A[i] + A[j] 的结果是大了还是小了，我们都可以排除掉一行或者一列的搜索空间。经过 nn 步以后，就能排除所有的搜索空间，检查完所有的可能性。搜索空间的减小过程如下面动图所示：



实际上还有几道题也是用到了这样的缩减搜索空间的思想：

11. Container With Most Water
240. Search a 2D Matrix II

作者：nettee
链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/yi-zhang-tu-gao-su-ni-on-de-shuang-zhi-zhen-jie-fa/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。